# Next.js 3주차

## Next.js란?

- Next.js는 React 기반의 프레임워크로, React에 기반한 프로젝트를 보다 편리하고 강력하게 구성할 수 있도록 다양한 기능을 제공한다.

- Vercel에서 개발 및 유지보수 중이며, React를 사용한 서버 사이드 렌더링(SSR)과 정적 사이트 생성(SSG)을 기본적으로 지원한다.

### 프레임워크 vs 라이브러리

프로그래밍에서 프레임워크와 라이브러리는 둘 다 개발을 도와주는 도구이지만, 개발의 주도권이 누구에게 있는지에 따라 성격이 뚜렷하게 나눠진다.

- 프레임워크: 전체적인 흐름을 프레임워크 자체가 주도하고, 개발자는 그 틀 안에서 개발한다. 기능이 대부분 내장되어 있어 빠르게 개발할 수 있지만 자유도가 낮다.
  -> 예: Next.js, Angular

- 라이브러리: 개발자가 주도해서 필요한 기능만 골라 사용한다. 자유도는 높지만 구성과 설정을 직접 설계해야한다.
  -> 예: React, Lodash

### 사전 렌더링(Pre-rendering)

사전 렌더링은 React의 기본 렌더링 방식인 CSR(Client Side Rendering)의 단점인 느린 초기 로딩(FCP)과 SEO 부족 문제를 해결하기 위해 도입된 방식이다.
브라우저가 요청하기 전에 HTML을 미리 생성해 두어, 빠른 응답성과 검색엔진 최적화(SEO)를 동시에 만족시킬 수 있다.
Next.js는 이러한 사전 렌더링을 위해 다음 3가지 방식을 제공함.

1. SSR(서버사이드 렌더링)

- 매 요청마다 서버에서 데이터를 불러와 HTML을 생성
- 항상 최신 데이터를 보여줘야 하는 페이지에 적합
- 함수: `getServerSideProps`
- 예: 실시간 가격, 로그인 정보, 뉴스 등

2. SSG(정적 사이트 생성)

- 빌드 시점에 HTML을 미리 생성
- 사용자 요청 시 매우 빠른 응답이 가능하지만, 데이터가 고정적이다.
- 함수: `getStaticProps`
- 예: 블로그 글, 제품 소개 페이지 등

3. ISR(증분 정적 재생성)

- 기본적으로 SSG처럼 작동하지만, 설정한 주기(revalidate)에 따라 페이지를 백그라운드에서 자동으로 갱신한다.
- 최신 데이터와 빠른 응답 속도를 모두 확보할 수 있다.
- 함수: `getStaticProps` + `revalidate`
- 추가 기능: On-Demand ISR (요청 시 강제 재생성)
- 예: 상품 리스트, 커뮤니티 글 목록 등 자주 갱신되지만 실시간까지는 필요없는 페이지

### 라우팅 시스템

Next.js에서는 사용자가 요청한 경로에 따라 어떤 페이지를 보여줄지를 결정하는 라우팅 시스템을 제공한다.
Next.js 13버전 이전까지는 `pages` 폴더를 기반으로 하는 페이지 라우터(Page Router) 방식만 존재했지만, 13버전부터는 새로운 방식인 앱 라우터(App Router)가 도입되어, 더 유연하고 구조적인 페이지 구성이 가능해졌다.

1. 페이지 라우터(Page Router)

페이지 라우터는 Next.js 초기부터 사용되던 전통적인 방식이다.
`pages/` 디렉토리 안에 파일을 만들면, 해당 파일명이 자동으로 URL 경로가 된다.
예를 들어 `pages/about.tsx` 파일은 `/about` 경로로 라우팅된다.

링크 이동은 `<Link href="/about" />` 컴포넌트를 사용하고, 프로그래매틱한 방식의 이동은 `useRouter().push("/about")` 같은 방식으로 처리한다.

동적 라우팅 예시

- `[id].tsx`: `/post/1`, `/user/abc` 같은 동적 파라미터 처리
- `[...id].tsx`: 여러 경로를 배열 형태로 처리(catch-all segment)
- `[[...id]].tsx`: 경로가 없어도 허용되는 optional catch-all segment

페이지 라우터는 간단하고 직관적이며, 소규모 프로젝트나 빠른 개발에는 여전히 유용하다.
하지만 레이아웃 구성의 유연성이 떨어지고, 모든 페이지가 클라이언트 컴포넌트로 구성된다는 단점이 있다.

2. 앱 라우터(App Router)

앱 라우터는 Next.js 13버전부터 도입된 신규 라우팅 시스템으로,
`app/` 디렉토리를 기반으로 경로를 구성한다. 각 디렉토리가 URL 경로를 의미하며, 그 안에 들어가는 특별한 파일들로 레이아웃, 페이지, 로딩 상태 등을 선언한다.

앱 라우터의 가장 큰 특징은 서버 컴포넌트를 기본적으로 사용한다는 점이다.
또한, 레이아웃을 디렉토리 단위로 분리할 수 있어서 코드 분할, 성능 최적화, 유지보수에 매우 유리하다.

### JS Bundle 최적화

Next.js는 페이지 렌더링 시 해당 페이지에 필요한 JavaScript만 분할해서 전달한다.
이 방식은 코드 스플리팅(Code Splitting)이라고 하며, 전체 애플리케이션을 한 번에 로딩하지 않고 필요한 부분만 불러오기 때문에 성능에 큰 도움이 된다.

특히, 전체 JS를 한꺼번에 전송하면 하이드레이션(Hydration)에 시간이 오래 걸리고 초기 로딩 속도가 느려질 수 있지만, Next.js는 페이지별로 필요한 JS만 전달하기 때문에 하이드레이션 시간이 짧아지고 UX가 개선된다.

### 프리페칭(Prefetching)

프리페칭은 사용자가 아직 이동하지 않은 페이지의 리소스를 미리 가져와 캐시에 저장해두는 기능이다.
덕분에 사용자가 해당 페이지를 클릭하면 훨씬 빠르게 전환할 수 있다.

1. 자동 프리페칭

- `<Link href="/about" />`를 사용할 경우, 브라우저 뷰포트에 해당 링크가 들어오면 자동으로 프리페칭이 수행된다.

2. 수동 프리페칭

- 프로그래매틱한 이동 방식(router.push)을 사용할 경우에는 자동 프리페칭이 적용되지 않는다.
- 이럴 땐 `useRouter().prefetch('/about')`처럼 수동으로 프리페칭을 지정해야 빠른 이동이 가능하다.

### API Routes

Next.js는 프론트엔드뿐 아니라, 간단한 백엔드 API 서버 역할도 함께 처리할 수 있다.
`/pages/api` 폴더 내부에 파일을 만들면, 해당 파일은 자동으로 API 엔드포인트로 변환된다.

예를 들어 `/pages/api/hello.ts` 파일이 있다면, `/api/hello` 경로로 GET 요청을 보낼 수 있다.

이 기능을 활용하면 별도의 서버 없이도 간단한 CRUD 처리나 데이터 전달을 구현할 수 있으며, 서버리스함수 형태로 자동 배포되기 때문에 매우 편리하다.

### 페이지 라우터 장단점 정리

장점

1. 파일 기반 라우팅이 간편하다

- `pages/` 폴더 내부에 파일을 생성하는 것만으로 자동으로 라우팅이 이루어지기 때문에, 복잡한 설정 없이 간단하고 직관적인 페이지 구성이 가능하다.

2. 사전 렌더링 방식을 다양하게 지원한다

- `getServerSideProps`, `getStaticProps`, `getStaticPaths`, `revalidate` 등을 통해 SSR, SSG, ISR 등 다양한 렌더링 전략을 페이지 단위로 손쉽게 구현할 수 있다.

단점

1. 페이지별 레이아웃 구성에 제약이 있다

- 모든 페이지에서 공통으로 사용하는 레이아웃을 `_app.tsx`파일에서 일괄 관리해야 하므로, 경로별로 다른 레이아웃을 적용하기가 어렵고 번거롭다.

2. 데이터 페칭 로직이 페이지 컴포넌트에 집중된다

- `getServerSideProps`나 `getStaticProps`는 페이지 컴포넌트에서만 사용할 수 있어, 컴포넌트 간 재사용이나 분리가 어렵고 유지보수가 불편해질 수 있다.

3. 불필요한 컴포넌트까지 JS 번들에 포함될 수 있다.

- 모든 컴포넌트가 클라이언트 컴포넌트로 처리되기 때문에, 사용하지 않는 부분도 번들에 포함되는 경우가 있어 초기 로딩 성능에 영향을 줄 수 있다.
